using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EasilyNET.AutoDependencyInjection.SourceGenerator;

/// <summary>
/// ModuleSourceGenerator
/// </summary>
[Generator]
public class AppModuleSourceGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 启动调试器
        //if (!Debugger.IsAttached)
        //{
        //    Debugger.Launch();
        //}
        // 注册语法接收器
        var classDeclarations = context.SyntaxProvider
                                       .CreateSyntaxProvider(static (s, _) => IsClassDeclarationWithAttributes(s),
                                           static (ctx, _) => GetClassDeclaration(ctx))
                                       .Where(static m => m is not null);
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());
        context.RegisterSourceOutput(compilationAndClasses, static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static bool IsClassDeclarationWithAttributes(SyntaxNode node)
    {
        var result = node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
        return result;
    }

    private static ClassDeclarationSyntax? GetClassDeclaration(GeneratorSyntaxContext context)
    {
        var result = context.Node as ClassDeclarationSyntax;
        return result;
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax?> classes, SourceProductionContext context)
    {
        var moduleTypes = (from classDeclaration in classes
                           let model = compilation.GetSemanticModel(classDeclaration.SyntaxTree)
                           select model.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol into symbol
                           where symbol != null && IsAppModule(symbol)
                           select symbol.ToDisplayString()).ToList();
        var sourceBuilder = new StringBuilder();
        sourceBuilder.AppendLine("// <auto-generated/>");
        sourceBuilder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sourceBuilder.AppendLine("using EasilyNET.AutoDependencyInjection.Abstractions;");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("/// <summary>");
        sourceBuilder.AppendLine("/// 注册App模块");
        sourceBuilder.AppendLine("/// </summary>");
        sourceBuilder.AppendLine("public static class AppModuleRegistration");
        sourceBuilder.AppendLine("{");
        sourceBuilder.AppendLine("    /// <summary>");
        sourceBuilder.AppendLine("    /// 注册AppModule");
        sourceBuilder.AppendLine("    /// </summary>");
        sourceBuilder.AppendLine("    /// <param name=\"services\"></param>");
        sourceBuilder.AppendLine("    public static void RegisterModules(IServiceCollection services)");
        sourceBuilder.AppendLine("    {");
        foreach (var moduleType in moduleTypes)
        {
            sourceBuilder.AppendLine($"        services.AddSingleton<IAppModule, {moduleType}>();");
        }
        sourceBuilder.AppendLine("    }");
        sourceBuilder.AppendLine("}");
        context.AddSource("AppModuleRegistration.g.cs", sourceBuilder.ToString());
    }

    /// <summary>
    /// 判断一个类型是否是符合条件的 AppModule。
    /// </summary>
    /// <param name="symbol">类型符号。</param>
    /// <returns>如果是符合条件的 AppModule，则返回 true；否则返回 false。</returns>
    private static bool IsAppModule(INamedTypeSymbol symbol)
    {
        var baseType = symbol.BaseType;
        while (baseType != null)
        {
            if (baseType.ToDisplayString() == "EasilyNET.AutoDependencyInjection.Modules.AppModule")
            {
                return true;
            }
            baseType = baseType.BaseType;
        }
        return false;
    }
}