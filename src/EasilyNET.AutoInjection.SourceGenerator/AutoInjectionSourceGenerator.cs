using System.Diagnostics;

namespace EasilyNET.AutoInjection.SourceGenerator;
//https://github.com/dotnet/roslyn/blob/main/docs/features/source-generators.cookbook.md
/// <summary>
/// 自动注入生成器
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class AutoInjectionSourceGenerator : ISourceGenerator
{
    /// <summary>
    /// 默认名字
    /// </summary>
    private const string DefaultName = "Injection";

    /// <summary>
    /// 名字前缀
    /// </summary>
    private const string Prefix = "Auto";


    public void Execute(GeneratorExecutionContext context)
    {
        var compilation = context.Compilation;
        // 获取已解析的语法树

        if (context.SyntaxContextReceiver is DependencySyntaxReceiver receiver)
        {

            var list = receiver.GetClassDatas();
            if (list.Any())
            {
                var globalOptions = context.AnalyzerConfigOptions.GlobalOptions;
                //得到全局命名空间
                globalOptions.TryGetValue("build_property.RootNamespace",
                    out var rootNamespace);
                if (rootNamespace == null)
                {
                    return;
                }

                //得到.csproj下配置名字
                //< PropertyGroup >
                //< InjectionName > Injection </ InjectionName >
                //</ PropertyGroup >
                //<ItemGroup >
                //<CompilerVisibleProperty Include = "InjectionName" />
                //</ItemGroup >
                globalOptions.TryGetValue("build_property.InjectionName",
                    out var methodName);

                //如果空值，就使用默认名
                if (string.IsNullOrWhiteSpace(methodName))
                {
                    methodName = DefaultName;
                }
                CodeGenerationContext codeContext = new();
                codeContext.WriteLines("// <auto-generated/>");
                codeContext.WriteLines("using EasilyNET.AutoDependencyInjection.Core;");
                codeContext.WriteLines("using EasilyNET.AutoDependencyInjection.Core.Abstractions;");
                codeContext.WriteLines("using System;");
                codeContext.WriteLines("using Microsoft.Extensions.DependencyInjection;");
                codeContext.WriteLines($"namespace {rootNamespace};");
                codeContext.WriteLines($"public static partial class _{Prefix}{methodName}");
                var add = "Add";
                using (codeContext.CodeBlock())
                {
                    codeContext.WriteLines($"public static IServiceCollection {add}{Prefix}{methodName}(this IServiceCollection services)");
                    using (codeContext.CodeBlock())
                    {
                        foreach (var temp in list)
                        {

                            foreach (var serviceType in temp.ServiceTypes)
                            {

                                codeContext.WriteLines($"services.Add(new ServiceDescriptor(typeof({GetTypeName(serviceType)}), typeof({GetTypeName(temp.ImplementationType)}),ServiceLifetime.{temp.Lifetime}));");
                            }
                        }
                        codeContext.WriteLines("return services;");
                    }
                }

                var sourceCode = codeContext.SourceCode;
                var extensionTextFormatted = CSharpSyntaxTree.ParseText(sourceCode).GetRoot().NormalizeWhitespace().SyntaxTree.GetText().ToString();

                context.AddSource($"{Prefix}{methodName}.g.cs", SourceText.From(extensionTextFormatted, Encoding.UTF8));
            }
        }

    }


    private string GetTypeName(ITypeSymbol typeSymbol)
    {

        if (typeSymbol is INamedTypeSymbol { IsGenericType: true } namedTypeSymbol)
        {
            var name = typeSymbol.Name;

            var typeParameters = namedTypeSymbol.TypeParameters;
            return $"{name}<{new string(',', typeParameters.Length - 1)}>";

        }
        return typeSymbol.ToDisplayString();
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        // if (!Debugger.IsAttached)
        // {
        //     Debugger.Launch();
        // }
        context.RegisterForSyntaxNotifications(static () => new DependencySyntaxReceiver());
    }
}

/// <summary>
/// 语法接入器
/// </summary>
internal sealed class DependencySyntaxReceiver : ISyntaxContextReceiver
{
    private const string TransientDependencyName = "EasilyNET.AutoDependencyInjection.Core.Abstractions.ITransientDependency";
    private const string ScopedDependencyName = "EasilyNET.AutoDependencyInjection.Core.Abstractions.IScopedDependency";
    private const string SingletonDependencyName = "EasilyNET.AutoDependencyInjection.Core.Abstractions.ISingletonDependency";
    private const string IgnoreDependencyAttributeName = "EasilyNET.AutoDependencyInjection.Core.Attributes.IgnoreDependencyAttribute";
    private const string DependencyInjectionAttributeName = "EasilyNET.AutoDependencyInjection.Core.Attributes.DependencyInjectionAttribute";
    private List<ClassData> _datas = [];
    /// <summary>
    /// 语法节点
    /// </summary>
    /// <param name="context"></param>
    public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
    {
        if (context.Node is ClassDeclarationSyntax classSyntax)
        {


            //语义模型
            var semanticModel = context.SemanticModel;

            //获取类型声明符号
            var typeSymbol = (ITypeSymbol)semanticModel.GetDeclaredSymbol(classSyntax)!; //定义成员

            if (typeSymbol.IsAbstract) //抽象
            {
                return;
            }
            var interfaces = typeSymbol.Interfaces;

            var attr = typeSymbol.GetAttributes().FirstOrDefault(o => o.AttributeClass?.ToDisplayString() == DependencyInjectionAttributeName);

            if (attr is not null)
            {
                var lifetime = (int)attr.ConstructorArguments[0].Value!;

                //是否要添加自己
                var addSelf = attr.ConstructorArguments.ElementAtOrDefault(1).Value;
                ClassData classData = new ClassData(typeSymbol, GetLifetime(lifetime));
                //添加自己
                //if (bool.TryParse(addSelf?.ToString(), out bool addSelfResult) && addSelfResult == true)
                //{
                //    classData.AddServiceTypes(new[] { typeSymbol });
                //}
                //else
                //{
                //    //假如没有接口，就添加自己，否则就添加接口
                //    classData.AddServiceTypes(typeSymbol.Interfaces.Any() ? typeSymbol.Interfaces : new[] { typeSymbol });
                //}
                classData.AddServiceTypes(bool.TryParse(addSelf?.ToString(), out var addSelfResult) && addSelfResult
                                              ? new[] { typeSymbol }
                                              : (typeSymbol.Interfaces.Any() ? typeSymbol.Interfaces : new[] { typeSymbol }));
                _datas.Add(classData);
                return;
            }

            var dependencyInterface = typeSymbol.Interfaces.SelectMany(o => o.Interfaces).FirstOrDefault(o => $"{TransientDependencyName},{ScopedDependencyName},{SingletonDependencyName}".Contains(o.ToDisplayString()));
            if (dependencyInterface is null)
            {
                return;
            }
            _datas.Add(new ClassData(typeSymbol, GetLifetime(dependencyInterface.ToDisplayString())).AddServiceTypes(interfaces));

            /// <summary>
            /// 获取类元数据列表。
            /// </summary>
            /// <returns></returns>
            //foreach (var @interface in interfaces)
            //{
            //    //得到要注入的接口
            //    var dependencyInterface = @interface.Interfaces.FirstOrDefault(o => $"{TransientDependencyName},{ScopedDependencyName},{SingletonDependencyName}".Contains(o.ToDisplayString()));
            //    if (dependencyInterface is not null)
            //    {
            //        var lifetime = GetLifetime(dependencyInterface.ToDisplayString());

            //    }
            //}
        }
    }



    private string GetLifetime(string value) =>
        value switch
        {
            SingletonDependencyName => "Singleton",
            ScopedDependencyName => "Scoped",
            TransientDependencyName => "Transient",
            _ => throw new NotImplementedException()
        };

    private string GetLifetime(int value) =>
        value switch
        {
            0 => "Singleton",
            1 => "Scoped",
            2 => "Transient",
            _ => throw new NotImplementedException()
        };


    /// <summary>
    /// 得到类型数据列表
    /// </summary>
    /// <returns></returns>
    public IReadOnlyCollection<ClassData> GetClassDatas()
    {
        return _datas.AsReadOnly();
    }

}


/// <summary>
/// 
/// </summary>
public sealed class ClassData
{
    /// <summary>
    /// 
    /// </summary>
    /// <param name="implementationType"></param>
    /// <param name="lifetime"></param>
    public ClassData(ITypeSymbol implementationType, string lifetime)
    {
        ImplementationType = implementationType;
        Lifetime = lifetime;
    }

    /// <summary>
    /// 
    /// </summary>
    public ITypeSymbol ImplementationType { get; }
    /// <summary>
    /// 
    /// </summary>
    public string Lifetime { get; }

    public List<ITypeSymbol> ServiceTypes { get; } = [];

    public ClassData AddServiceTypes(IEnumerable<ITypeSymbol> serviceTypes)
    {
        ServiceTypes.AddRange(serviceTypes);

        return this;
    }
}